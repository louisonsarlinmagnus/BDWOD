{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Description du projet Pour facilit\u00e9 la cr\u00e9ation d\u2019entra\u00eenement on souhaite constitu\u00e9 dans un premier temps une base de donn\u00e9e d\u2019exercices. Cette base de donn\u00e9e pourra par la suite \u00eatre exploit\u00e9 par un logiciel ou une application mobile. Il n'est pour l'instant pas envisag\u00e9 de cr\u00e9er un \"cr\u00e9ateur de WOD\" , mais plut\u00f4t un moteur de recherche de WOD .","title":"Accueil"},{"location":"#description-du-projet","text":"Pour facilit\u00e9 la cr\u00e9ation d\u2019entra\u00eenement on souhaite constitu\u00e9 dans un premier temps une base de donn\u00e9e d\u2019exercices. Cette base de donn\u00e9e pourra par la suite \u00eatre exploit\u00e9 par un logiciel ou une application mobile. Il n'est pour l'instant pas envisag\u00e9 de cr\u00e9er un \"cr\u00e9ateur de WOD\" , mais plut\u00f4t un moteur de recherche de WOD .","title":"Description du projet"},{"location":"bddjson/","text":"La base de donn\u00e9es JSON Dans la continuit\u00e9 de l'analyse pr\u00e9c\u00e9dente je propose une architecture JSON . Ce format pourrait \u00eatre utiliser pour envoyer les donn\u00e9es vers l'application dans l'\u00e9ventualit\u00e9 d'un serveur distant. { \"Entrainement\" : { \"nom\" : \"\" , \"date\" : \"\" , \"lieu\" : \"\" , \"commentaire\" : \"\" , \"Exercice\" : [ { \"nom\" : \"\" , \"type\" : \"\" , \"cash-in\" : \"\" , \"temps\" : 0 , \"evolution_reps\" : \"\" , \"nombre_tours\" : 1 , \"time_cap\" : 900 , \"dur\u00e9e_intervalle\" : 1 , \"plusieur_mvt_par_intervalle\" : false , \"mouvement_altern\u00e9\" : true , \"temps_travail\" : 20 , \"temps_repos\" : 10 , \"cash-out\" : \"\" , \"mouvement\" : [ { \"nom\" : \"\" , \"nbr_reps\" : 1 , \"poids\" : 0 , \"distance\" : 0 , \"hauteur\" : 0 , \"temps\" : 0 , }, ], }, ], }, } On voit plus pr\u00e9cis\u00e9ment le mod\u00e8le qu'adoptera la donn\u00e9e. \u00c9videment les attributs seront utilisable sous certaines conditions par exemple l'attribut \"temps_travail\" sera disponible uniquement pour un exercice de type \"Tabata\".","title":"Base de donn\u00e9e JSON"},{"location":"bddjson/#la-base-de-donnees-json","text":"Dans la continuit\u00e9 de l'analyse pr\u00e9c\u00e9dente je propose une architecture JSON . Ce format pourrait \u00eatre utiliser pour envoyer les donn\u00e9es vers l'application dans l'\u00e9ventualit\u00e9 d'un serveur distant. { \"Entrainement\" : { \"nom\" : \"\" , \"date\" : \"\" , \"lieu\" : \"\" , \"commentaire\" : \"\" , \"Exercice\" : [ { \"nom\" : \"\" , \"type\" : \"\" , \"cash-in\" : \"\" , \"temps\" : 0 , \"evolution_reps\" : \"\" , \"nombre_tours\" : 1 , \"time_cap\" : 900 , \"dur\u00e9e_intervalle\" : 1 , \"plusieur_mvt_par_intervalle\" : false , \"mouvement_altern\u00e9\" : true , \"temps_travail\" : 20 , \"temps_repos\" : 10 , \"cash-out\" : \"\" , \"mouvement\" : [ { \"nom\" : \"\" , \"nbr_reps\" : 1 , \"poids\" : 0 , \"distance\" : 0 , \"hauteur\" : 0 , \"temps\" : 0 , }, ], }, ], }, } On voit plus pr\u00e9cis\u00e9ment le mod\u00e8le qu'adoptera la donn\u00e9e. \u00c9videment les attributs seront utilisable sous certaines conditions par exemple l'attribut \"temps_travail\" sera disponible uniquement pour un exercice de type \"Tabata\".","title":"La base de donn\u00e9es JSON"},{"location":"bddsql/","text":"La base de donn\u00e9es SQL Pour stocker les exercices nous avons chercher un moyen simple, l\u00e9ger, efficace et portable. Les recherches on men\u00e9 a \u00e9liminer les services de serveur de base de donn\u00e9es relationnelles tels que MySQL et PostgreSQL , en effet ces technologie ne sont pas portable et complexe. Puis les donn\u00e9es format\u00e9 tels que XML et JSON ont \u00e9t\u00e9 \u00e9cart\u00e9 pour des raisons de fiabilit\u00e9 et de simplicit\u00e9. Nous avons donc choisi de travailler avec SQLite , en effet ce service permet de g\u00e9rer un BDD de type SQL tout en restant portable et simple \u00e0 mettre ne \u0153uvre. En effet SQLite ne demande pas la mise en place d'un serveur de BDD, les donn\u00e9es sont stock\u00e9es sur un seul fichier. C'est donc une solution portable que l'on retrouve dans beaucoup d'appareil et notamment dans l'OS Android. Les mod\u00e8les de donn\u00e9es La technologie ayant \u00e9t\u00e9 choisi il est temps de s'y mettre. La premi\u00e8re \u00e9tape est bien \u00e9videment la recherche d'informations. C'est ainsi qu'on a d\u00e9cid\u00e9 d'appliqu\u00e9 un mod\u00e8le de conception de base de donn\u00e9e, le mod\u00e8le \" Merise \" . On retiendra donc que Merise permet de : d\u00e9crire les donn\u00e9es gr\u00e2ce au MCD : quelles sont les relations et les d\u00e9pendances entres les diff\u00e9rents acteurs. d'impl\u00e9menter logiquement gr\u00e2ce au MLD du point pr\u00e9c\u00e9dent. Proposer une construction concr\u00e8te et utilisable du point pr\u00e9c\u00e9dent gr\u00e2ce au MPD Le MCD Le MCD est constitu\u00e9 des \u00e9l\u00e9ments suivants: Les entit\u00e9s (1 rectangle = 1 objet) Les propri\u00e9t\u00e9s (la liste des donn\u00e9es de l\u2019entit\u00e9) Les relations qui expliquent et pr\u00e9cisent comment les entit\u00e9s sont reli\u00e9es entre elles (les ovales) Les cardinalit\u00e9s (les petits chiffres au dessus des \"pattes\") Figure 2: Mod\u00e8le Conceptuel de Donn\u00e9e a faire Le MPD Concr\u00e8tement, cette \u00e9tape permet de construire la structure finale de la base de donn\u00e9es avec les diff\u00e9rents liens entre les \u00e9l\u00e9ments qui la composent. Pour la peine, on change aussi de vocabulaire : Les entit\u00e9s se transforment en tables ; Les propri\u00e9t\u00e9s se transforment en attributs Les propri\u00e9t\u00e9s se trouvant au milieu d\u2019une relation g\u00e9n\u00e8rent une nouvelle table. Les identifiants se transforment en cl\u00e9s et se retrouvent soulign\u00e9s. Chaque table dispose d\u2019au minimum une cl\u00e9 primaire Les relations et les cardinalit\u00e9s se transforment en champs parfois soulign\u00e9s : il s\u2019agit de cr\u00e9er des \"cl\u00e9s \u00e9trang\u00e8res\" reli\u00e9es \u00e0 une \"cl\u00e9 primaire\" dans une autre table Figure 3: Mod\u00e8le Physique de Donn\u00e9e \u00e0 faire Le MLD On repr\u00e9sente ainsi les donn\u00e9es issues de la mod\u00e9lisation Merise sous la forme suivante : Chaque ligne repr\u00e9sente une table C\u2019est toujours le nom de la table qui est \u00e9crit en premier Les champs sont list\u00e9s entre parenth\u00e8ses et s\u00e9par\u00e9s par des virgules Les cl\u00e9s primaires sont soulign\u00e9es et plac\u00e9es au d\u00e9but de la liste des champs Les cl\u00e9s \u00e9trang\u00e8res sont pr\u00e9fix\u00e9es par un di\u00e8se Cette \u00e9tape ne porte pas d'int\u00e9r\u00eat dans le cadre de notre projet, elle a donc \u00e9t\u00e9 saut\u00e9e. 3.1.2 Le Script SQL Une fois les mod\u00e8les conceptuels et physiques cr\u00e9es, il reste a cr\u00e9er le script de cr\u00e9ation de la base de donn\u00e9es mod\u00e9lis\u00e9e. Pour ceci nous allons devoir nous pencher sur le langage SQL. Chaque SGBD (Syst\u00e8me de Gestion de Base de Donn\u00e9es) poss\u00e8de ses propres sp\u00e9cificit\u00e9s et caract\u00e9ristiques. Nous allons devoir donc cr\u00e9er un script SQL respectant les notations et caract\u00e9ristiques de SQlite. On se retrouve donc avec le script suivant: DROP TABLE IF EXISTS \"Entrainement\" ; CREATE TABLE IF NOT EXISTS \"Entrainement\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"nom\" TEXT , \"date\" NUMERIC , \"lieu\" TEXT , \"commentaire\" TEXT ); /*Creation de la Table Exercice*/ DROP TABLE IF EXISTS \"Exercice\" ; CREATE TABLE IF NOT EXISTS \"Exercice\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"nom\" TEXT , \"type\" TEXT , \"cashin\" TEXT , \"temps\" INTEGER , \"evolution_reps\" TEXT , \"nombre_tours\" INTEGER , \"time_cap\" INTEGER , \"dur\u00e9e_intervalle\" INTEGER , \"plusieur_mvt_par_intervalle\" NUMERIC , \"mouvement_altern\u00e9\" NUMERIC , \"temps_travail\" INTEGER , \"temps_repos\" INTEGER , \"cash-out\" TEXT ); /*Creation de la Table Mouvement*/ DROP TABLE IF EXISTS \"Mouvement\" ; CREATE TABLE IF NOT EXISTS \"Mouvement\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"nom\" TEXT , \"nbr_reps\" INTEGER , \"poids\" INTEGER , \"distance\" INTEGER , \"hauteur\" INTEGER \"temps\" INTEGER ); /*Creation de la Table Constitue*/ DROP TABLE IF EXISTS \"Constitue\" ; CREATE TABLE IF NOT EXISTS \"Constitue\" ( \"ExerciceId\" INTEGER NOT NULL , \"EntrainementId\" INTEGER NOT NULL , FOREIGN KEY ( \"ExerciceId\" ) REFERENCES \"Exercice\" ( \"id\" ) ON DELETE CASCADE ON UPDATE NO ACTION , FOREIGN KEY ( \"EntrainementId\" ) REFERENCES \"Entrainement\" ( \"id\" ) ON DELETE CASCADE ON UPDATE NO ACTION ); CREATE UNIQUE INDEX \"iConstitue\" ON \"Constitue\" ( \"ExerciceId\" , \"EntrainementId\" ); /*Creation de la Table Fait*/ DROP TABLE IF EXISTS \"Fait\" ; CREATE TABLE IF NOT EXISTS \"Fait\" ( \"MouvementId\" INTEGER NOT NULL , \"ExerciceId\" INTEGER NOT NULL , FOREIGN KEY ( \"MouvementId\" ) REFERENCES \"Mouvement\" ( \"id\" ) ON DELETE CASCADE ON UPDATE NO ACTION , FOREIGN KEY ( \"ExerciceId\" ) REFERENCES \"Exercice\" ( \"id\" ) ON DELETE CASCADE ON UPDATE NO ACTION ); CREATE UNIQUE INDEX \"iFait\" ON \"Fait\" ( \"MouvementId\" , \"ExerciceId\" ); Il faut chercher si on ajoute des unique quelque part ou si \u00e7a sert a rien. Nous avons donc ajouter des UNIQUE et des INDEX. Un fois le script de cr\u00e9ation de la base de donn\u00e9e compl\u00e8tement cr\u00e9er il ne reste plus qu'a le \"fournir\" \u00e0 SQLite pour le transformer en base de donn\u00e9e. Ce script a pour extension \".sql\" . Un fois SQLite \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9 : On ouvre la BDD (ou on cr\u00e9e la BDD si elle n'existe pas) avec la commande : .open BDWOD.db On set la visualisation d'une requ\u00eate en mode colonne : .mode column On active l'affichage de l'ent\u00eate pour des raison de visibilit\u00e9 : .header on On ex\u00e9cute le script .sql de cr\u00e9ation de la base de donn\u00e9e: .read script_BDWOD.sql *Figure 4: Shell SQLite pour la cr\u00e9ation d'une base de donn\u00e9es* Remplir la base de donn\u00e9e Une fois la base de donn\u00e9es cr\u00e9e il faut y rentrer les donn\u00e9es en question. Pour cela nous allons devoir cr\u00e9er un autre script SQL. Mais avant de commencer a coder nous pouvons nous pencher sur l' annexe 1 . Il est maintenant envisageable de remplir correctement notre base de donn\u00e9e. Pour cela j'ai choisi cet exemple Description Entrainement: \u2003 CrossFit Terrasse \u200301/05/2020 \u2003Entrainement complet et assez long Warmup : 3 Rounds \u2003 3 Tiger Push-ups \u2003 6 V-ups \u2003 9 Sumo Squats For Time : 4 Rounds, TC: 20\u2019 \u2003 Cash-in 50 DU \u2003 10 Pull-ups \u2003 20 Squat Snatches \u2003 30\" Gainage \u2003 Cash-out 50 DU EMOM : 12' \u2003 10 Leg Raise \u2003 20 Sit-ups On remarque bien que cet entra\u00eenement comporte: Une description avec le lieu, la date et une description Un \"Warmup\" de 3 Rounds avec plusieurs mouvement Un premier exercice de 4 Rounds et un Time Cap de 20 minutes. Compos\u00e9 d'un cash-in et d'un cash-out qui sont des argument du mouvement. Et enfin de mouvements. Un second exercice d'un temps de 12 minutes, plusieurs mouvements.","title":"Base de donn\u00e9e SQL"},{"location":"bddsql/#la-base-de-donnees-sql","text":"Pour stocker les exercices nous avons chercher un moyen simple, l\u00e9ger, efficace et portable. Les recherches on men\u00e9 a \u00e9liminer les services de serveur de base de donn\u00e9es relationnelles tels que MySQL et PostgreSQL , en effet ces technologie ne sont pas portable et complexe. Puis les donn\u00e9es format\u00e9 tels que XML et JSON ont \u00e9t\u00e9 \u00e9cart\u00e9 pour des raisons de fiabilit\u00e9 et de simplicit\u00e9. Nous avons donc choisi de travailler avec SQLite , en effet ce service permet de g\u00e9rer un BDD de type SQL tout en restant portable et simple \u00e0 mettre ne \u0153uvre. En effet SQLite ne demande pas la mise en place d'un serveur de BDD, les donn\u00e9es sont stock\u00e9es sur un seul fichier. C'est donc une solution portable que l'on retrouve dans beaucoup d'appareil et notamment dans l'OS Android.","title":"La base de donn\u00e9es SQL"},{"location":"bddsql/#les-modeles-de-donnees","text":"La technologie ayant \u00e9t\u00e9 choisi il est temps de s'y mettre. La premi\u00e8re \u00e9tape est bien \u00e9videment la recherche d'informations. C'est ainsi qu'on a d\u00e9cid\u00e9 d'appliqu\u00e9 un mod\u00e8le de conception de base de donn\u00e9e, le mod\u00e8le \" Merise \" . On retiendra donc que Merise permet de : d\u00e9crire les donn\u00e9es gr\u00e2ce au MCD : quelles sont les relations et les d\u00e9pendances entres les diff\u00e9rents acteurs. d'impl\u00e9menter logiquement gr\u00e2ce au MLD du point pr\u00e9c\u00e9dent. Proposer une construction concr\u00e8te et utilisable du point pr\u00e9c\u00e9dent gr\u00e2ce au MPD","title":"Les mod\u00e8les de donn\u00e9es"},{"location":"bddsql/#le-mcd","text":"Le MCD est constitu\u00e9 des \u00e9l\u00e9ments suivants: Les entit\u00e9s (1 rectangle = 1 objet) Les propri\u00e9t\u00e9s (la liste des donn\u00e9es de l\u2019entit\u00e9) Les relations qui expliquent et pr\u00e9cisent comment les entit\u00e9s sont reli\u00e9es entre elles (les ovales) Les cardinalit\u00e9s (les petits chiffres au dessus des \"pattes\") Figure 2: Mod\u00e8le Conceptuel de Donn\u00e9e a faire","title":"Le MCD"},{"location":"bddsql/#le-mpd","text":"Concr\u00e8tement, cette \u00e9tape permet de construire la structure finale de la base de donn\u00e9es avec les diff\u00e9rents liens entre les \u00e9l\u00e9ments qui la composent. Pour la peine, on change aussi de vocabulaire : Les entit\u00e9s se transforment en tables ; Les propri\u00e9t\u00e9s se transforment en attributs Les propri\u00e9t\u00e9s se trouvant au milieu d\u2019une relation g\u00e9n\u00e8rent une nouvelle table. Les identifiants se transforment en cl\u00e9s et se retrouvent soulign\u00e9s. Chaque table dispose d\u2019au minimum une cl\u00e9 primaire Les relations et les cardinalit\u00e9s se transforment en champs parfois soulign\u00e9s : il s\u2019agit de cr\u00e9er des \"cl\u00e9s \u00e9trang\u00e8res\" reli\u00e9es \u00e0 une \"cl\u00e9 primaire\" dans une autre table Figure 3: Mod\u00e8le Physique de Donn\u00e9e \u00e0 faire","title":"Le MPD"},{"location":"bddsql/#le-mld","text":"On repr\u00e9sente ainsi les donn\u00e9es issues de la mod\u00e9lisation Merise sous la forme suivante : Chaque ligne repr\u00e9sente une table C\u2019est toujours le nom de la table qui est \u00e9crit en premier Les champs sont list\u00e9s entre parenth\u00e8ses et s\u00e9par\u00e9s par des virgules Les cl\u00e9s primaires sont soulign\u00e9es et plac\u00e9es au d\u00e9but de la liste des champs Les cl\u00e9s \u00e9trang\u00e8res sont pr\u00e9fix\u00e9es par un di\u00e8se Cette \u00e9tape ne porte pas d'int\u00e9r\u00eat dans le cadre de notre projet, elle a donc \u00e9t\u00e9 saut\u00e9e.","title":"Le MLD"},{"location":"bddsql/#312-le-script-sql","text":"Une fois les mod\u00e8les conceptuels et physiques cr\u00e9es, il reste a cr\u00e9er le script de cr\u00e9ation de la base de donn\u00e9es mod\u00e9lis\u00e9e. Pour ceci nous allons devoir nous pencher sur le langage SQL. Chaque SGBD (Syst\u00e8me de Gestion de Base de Donn\u00e9es) poss\u00e8de ses propres sp\u00e9cificit\u00e9s et caract\u00e9ristiques. Nous allons devoir donc cr\u00e9er un script SQL respectant les notations et caract\u00e9ristiques de SQlite. On se retrouve donc avec le script suivant: DROP TABLE IF EXISTS \"Entrainement\" ; CREATE TABLE IF NOT EXISTS \"Entrainement\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"nom\" TEXT , \"date\" NUMERIC , \"lieu\" TEXT , \"commentaire\" TEXT ); /*Creation de la Table Exercice*/ DROP TABLE IF EXISTS \"Exercice\" ; CREATE TABLE IF NOT EXISTS \"Exercice\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"nom\" TEXT , \"type\" TEXT , \"cashin\" TEXT , \"temps\" INTEGER , \"evolution_reps\" TEXT , \"nombre_tours\" INTEGER , \"time_cap\" INTEGER , \"dur\u00e9e_intervalle\" INTEGER , \"plusieur_mvt_par_intervalle\" NUMERIC , \"mouvement_altern\u00e9\" NUMERIC , \"temps_travail\" INTEGER , \"temps_repos\" INTEGER , \"cash-out\" TEXT ); /*Creation de la Table Mouvement*/ DROP TABLE IF EXISTS \"Mouvement\" ; CREATE TABLE IF NOT EXISTS \"Mouvement\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"nom\" TEXT , \"nbr_reps\" INTEGER , \"poids\" INTEGER , \"distance\" INTEGER , \"hauteur\" INTEGER \"temps\" INTEGER ); /*Creation de la Table Constitue*/ DROP TABLE IF EXISTS \"Constitue\" ; CREATE TABLE IF NOT EXISTS \"Constitue\" ( \"ExerciceId\" INTEGER NOT NULL , \"EntrainementId\" INTEGER NOT NULL , FOREIGN KEY ( \"ExerciceId\" ) REFERENCES \"Exercice\" ( \"id\" ) ON DELETE CASCADE ON UPDATE NO ACTION , FOREIGN KEY ( \"EntrainementId\" ) REFERENCES \"Entrainement\" ( \"id\" ) ON DELETE CASCADE ON UPDATE NO ACTION ); CREATE UNIQUE INDEX \"iConstitue\" ON \"Constitue\" ( \"ExerciceId\" , \"EntrainementId\" ); /*Creation de la Table Fait*/ DROP TABLE IF EXISTS \"Fait\" ; CREATE TABLE IF NOT EXISTS \"Fait\" ( \"MouvementId\" INTEGER NOT NULL , \"ExerciceId\" INTEGER NOT NULL , FOREIGN KEY ( \"MouvementId\" ) REFERENCES \"Mouvement\" ( \"id\" ) ON DELETE CASCADE ON UPDATE NO ACTION , FOREIGN KEY ( \"ExerciceId\" ) REFERENCES \"Exercice\" ( \"id\" ) ON DELETE CASCADE ON UPDATE NO ACTION ); CREATE UNIQUE INDEX \"iFait\" ON \"Fait\" ( \"MouvementId\" , \"ExerciceId\" ); Il faut chercher si on ajoute des unique quelque part ou si \u00e7a sert a rien. Nous avons donc ajouter des UNIQUE et des INDEX. Un fois le script de cr\u00e9ation de la base de donn\u00e9e compl\u00e8tement cr\u00e9er il ne reste plus qu'a le \"fournir\" \u00e0 SQLite pour le transformer en base de donn\u00e9e. Ce script a pour extension \".sql\" . Un fois SQLite \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9 : On ouvre la BDD (ou on cr\u00e9e la BDD si elle n'existe pas) avec la commande : .open BDWOD.db On set la visualisation d'une requ\u00eate en mode colonne : .mode column On active l'affichage de l'ent\u00eate pour des raison de visibilit\u00e9 : .header on On ex\u00e9cute le script .sql de cr\u00e9ation de la base de donn\u00e9e: .read script_BDWOD.sql *Figure 4: Shell SQLite pour la cr\u00e9ation d'une base de donn\u00e9es*","title":"3.1.2 Le Script SQL"},{"location":"bddsql/#remplir-la-base-de-donnee","text":"Une fois la base de donn\u00e9es cr\u00e9e il faut y rentrer les donn\u00e9es en question. Pour cela nous allons devoir cr\u00e9er un autre script SQL. Mais avant de commencer a coder nous pouvons nous pencher sur l' annexe 1 . Il est maintenant envisageable de remplir correctement notre base de donn\u00e9e. Pour cela j'ai choisi cet exemple Description Entrainement: \u2003 CrossFit Terrasse \u200301/05/2020 \u2003Entrainement complet et assez long Warmup : 3 Rounds \u2003 3 Tiger Push-ups \u2003 6 V-ups \u2003 9 Sumo Squats For Time : 4 Rounds, TC: 20\u2019 \u2003 Cash-in 50 DU \u2003 10 Pull-ups \u2003 20 Squat Snatches \u2003 30\" Gainage \u2003 Cash-out 50 DU EMOM : 12' \u2003 10 Leg Raise \u2003 20 Sit-ups On remarque bien que cet entra\u00eenement comporte: Une description avec le lieu, la date et une description Un \"Warmup\" de 3 Rounds avec plusieurs mouvement Un premier exercice de 4 Rounds et un Time Cap de 20 minutes. Compos\u00e9 d'un cash-in et d'un cash-out qui sont des argument du mouvement. Et enfin de mouvements. Un second exercice d'un temps de 12 minutes, plusieurs mouvements.","title":"Remplir la base de donn\u00e9e"},{"location":"besoin/","text":"Analyse du besoin Dans cette partie on se questionnera sur les fonctionnalit\u00e9 voulue et le fonctionnement global. Enonc\u00e9 des conditions Faire une base de donn\u00e9e d'entrainement de sport (Entrainement) Un entrainement peut avoir un lieu Un entrainement a une date Un entrainement peut \u00eatre localis\u00e9 Un entrainement est constitu\u00e9 d'au moins un exercice (Exercice) Un exercice peut avoir un nom Un exercice peut \u00eatre un \u00e9chauffement Un exercice peut \u00eatre un Benchmark Un exercice a un Type (Type) etc. D\u00e9composition Un entra\u00eenement : Un nom (optionnel) Une date Un lieu (optionnel) Un \u00e9chauffement Un exercice Un exercice (ou \u00e9chauffement): Nom (optionnel) Est un \u00e9chauffement? (oui/non) Est un Benchmark? (oui/non) Type d'exercice (For Time, AMRAP, EMOM, TABATA) Un AMRAP : A un cash-in? (oui/non) A un cash-out? (oui/non) Temps Repos entre tours (optionnel) Mouvement(s) Un For Time : A un cash-in? (oui/non) A un cash-out? (oui/non) A les m\u00eames r\u00e9p\u00e9tition pour les mouvement? (oui/non) Si (A les m\u00eames r\u00e9p\u00e9tition pour les mouvement?) \u00c9volution des reps Nombre de tours (Au moins 1) Time Cap (optionnel) Repos entre tours (optionnel) Mouvement(s) Un EMOM : Intervalle (d\u00e9faut=1) Un ou plusieurs mouvement par intervalle? (oui/non) Mouvement altern\u00e9 \u00e0 chaque intervalle (oui/non) Un TABATA : Temps de travail Temps de repos Un ou plusieurs mouvement par intervalle? (oui/non) Mouvement altern\u00e9 \u00e0 chaque intervalle (oui/non) Un mouvement : Un mouvement physique Un nombre de reps (optionnel) [Sauf Tabata] Un poids (optionnel) Une distance (optionnel) [Sauf Tabata] Une hauteur (optionnel) Un temps (optionnel) [Sauf Tabata] Si on prend un exemple concret on peut avoir: Description Entrainement: \u2003 CrossFit Terrasse \u200301/05/2020 \u2003Entrainement complet On retrouve la description Le lieu de l\u2019entra\u00eenement La date Un commentaire Text lieuEntrainement=\"CrossFit-Terrasse\" Date dateEntrainement=\"01/05/2020\" Text descriptionEntrainement=\"Entrainement complet\" Warmup : 3 Rounds \u2003 3 Tiger Push-ups \u2003 6 V-ups \u2003 9 Sumo Squats Le Warmup est un For Time On a un nombre de r\u00e9p\u00e9tition simple On a ni cash-in/cash-out, ni nombre de r\u00e9p\u00e9tition \u00e9volutif On fait 3 tours sans Time Cap new ForTime ;isWarmup=true; Label=\"Warmup\" isReps=true;int nbrRep=3;Text mvt=\"Tiger Push-ups\" isReps=true;int nbrRep=9;Text mvt=\"Sumo Squats\" For Time : 4 Rounds, TC: 20\u2019 \u2003 Cash-in 50 DU \u2003 10 Pull-ups \u2003 20 Squat Snatches \u2003 30\" Gainage \u2003 Cash-out 50 DU L'exercice est un For Time de 4 tours en 20 minutes On a un cash-in et un cash-out On fait 30 secondes de gainage new ForTime ; nbrRound=4; TimeCap=20m isCashIn=true;isCashOut=true mvtCashIn=\"DU\"; repsCashIn=50 isTime=true; time=30s mvtCashIn=\"DU\"; repsCashIn=50 EMOM : 12' \u2003 10 Leg Raise \u2003 20 Sit-ups On fait un EMOM avec 1 minute en intervalle (=d\u00e9faut) On alterne le mouvement \u00e0 chaque intervalle new Emom; timeEmom=12m; isAltern=true; isMememvt=false isReps=true;int nbrRep=20;Text mvt=\"Sit-ups\" On voit a partir de ce table le fonctionnement qu'aurait l'application.","title":"Analyse du besoin"},{"location":"besoin/#analyse-du-besoin","text":"Dans cette partie on se questionnera sur les fonctionnalit\u00e9 voulue et le fonctionnement global.","title":"Analyse du besoin"},{"location":"besoin/#enonce-des-conditions","text":"Faire une base de donn\u00e9e d'entrainement de sport (Entrainement) Un entrainement peut avoir un lieu Un entrainement a une date Un entrainement peut \u00eatre localis\u00e9 Un entrainement est constitu\u00e9 d'au moins un exercice (Exercice) Un exercice peut avoir un nom Un exercice peut \u00eatre un \u00e9chauffement Un exercice peut \u00eatre un Benchmark Un exercice a un Type (Type) etc.","title":"Enonc\u00e9 des conditions"},{"location":"besoin/#decomposition","text":"Un entra\u00eenement : Un nom (optionnel) Une date Un lieu (optionnel) Un \u00e9chauffement Un exercice Un exercice (ou \u00e9chauffement): Nom (optionnel) Est un \u00e9chauffement? (oui/non) Est un Benchmark? (oui/non) Type d'exercice (For Time, AMRAP, EMOM, TABATA) Un AMRAP : A un cash-in? (oui/non) A un cash-out? (oui/non) Temps Repos entre tours (optionnel) Mouvement(s) Un For Time : A un cash-in? (oui/non) A un cash-out? (oui/non) A les m\u00eames r\u00e9p\u00e9tition pour les mouvement? (oui/non) Si (A les m\u00eames r\u00e9p\u00e9tition pour les mouvement?) \u00c9volution des reps Nombre de tours (Au moins 1) Time Cap (optionnel) Repos entre tours (optionnel) Mouvement(s) Un EMOM : Intervalle (d\u00e9faut=1) Un ou plusieurs mouvement par intervalle? (oui/non) Mouvement altern\u00e9 \u00e0 chaque intervalle (oui/non) Un TABATA : Temps de travail Temps de repos Un ou plusieurs mouvement par intervalle? (oui/non) Mouvement altern\u00e9 \u00e0 chaque intervalle (oui/non) Un mouvement : Un mouvement physique Un nombre de reps (optionnel) [Sauf Tabata] Un poids (optionnel) Une distance (optionnel) [Sauf Tabata] Une hauteur (optionnel) Un temps (optionnel) [Sauf Tabata] Si on prend un exemple concret on peut avoir: Description Entrainement: \u2003 CrossFit Terrasse \u200301/05/2020 \u2003Entrainement complet On retrouve la description Le lieu de l\u2019entra\u00eenement La date Un commentaire Text lieuEntrainement=\"CrossFit-Terrasse\" Date dateEntrainement=\"01/05/2020\" Text descriptionEntrainement=\"Entrainement complet\" Warmup : 3 Rounds \u2003 3 Tiger Push-ups \u2003 6 V-ups \u2003 9 Sumo Squats Le Warmup est un For Time On a un nombre de r\u00e9p\u00e9tition simple On a ni cash-in/cash-out, ni nombre de r\u00e9p\u00e9tition \u00e9volutif On fait 3 tours sans Time Cap new ForTime ;isWarmup=true; Label=\"Warmup\" isReps=true;int nbrRep=3;Text mvt=\"Tiger Push-ups\" isReps=true;int nbrRep=9;Text mvt=\"Sumo Squats\" For Time : 4 Rounds, TC: 20\u2019 \u2003 Cash-in 50 DU \u2003 10 Pull-ups \u2003 20 Squat Snatches \u2003 30\" Gainage \u2003 Cash-out 50 DU L'exercice est un For Time de 4 tours en 20 minutes On a un cash-in et un cash-out On fait 30 secondes de gainage new ForTime ; nbrRound=4; TimeCap=20m isCashIn=true;isCashOut=true mvtCashIn=\"DU\"; repsCashIn=50 isTime=true; time=30s mvtCashIn=\"DU\"; repsCashIn=50 EMOM : 12' \u2003 10 Leg Raise \u2003 20 Sit-ups On fait un EMOM avec 1 minute en intervalle (=d\u00e9faut) On alterne le mouvement \u00e0 chaque intervalle new Emom; timeEmom=12m; isAltern=true; isMememvt=false isReps=true;int nbrRep=20;Text mvt=\"Sit-ups\" On voit a partir de ce table le fonctionnement qu'aurait l'application.","title":"D\u00e9composition"},{"location":"exp-bdd/","text":"Exp\u00e9rimentations en base de donn\u00e9es En utilisant une base de donn\u00e9es bien plus simple (figure Y.1.5) pour faire des tests j'ai pu me rendre compte de certain probl\u00e8mes dans notre base (qui seront r\u00e9gl\u00e9s plus tard). \u00c7a m'a aussi permis de comprendre plusieurs choses expliqu\u00e9es dans la suite. Figure Y.1.5: Base de donn\u00e9es de cuisine Pour cr\u00e9er cette base de donn\u00e9es il faut le script suivant: DROP TABLE IF EXISTS \"Ingredient\" ; CREATE TABLE IF NOT EXISTS \"Ingredient\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"Nom_Ingredient\" TEXT UNIQUE ); DROP TABLE IF EXISTS \"Recette\" ; CREATE TABLE IF NOT EXISTS \"Recette\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"Nom_Recette\" TEXT UNIQUE ); DROP TABLE IF EXISTS \"Constitue\" ; CREATE TABLE IF NOT EXISTS \"Constitue\" ( \"Recette_id\" INTEGER NOT NULL , \"Ingredient_id\" INTEGER NOT NULL , FOREIGN KEY ( Recette_id ) REFERENCES Recette ( id ) ON DELETE CASCADE ON UPDATE NO ACTION , FOREIGN KEY ( Ingredient_id ) REFERENCES Ingredient ( id ) ON DELETE CASCADE ON UPDATE NO ACTION ); On remarque d\u00e9j\u00e0 que nous avons omis la contrainte UNIQUE pour certain attributs qui permettent d'\u00e9viter les doublons. Ensuite nous avons simplement ajouter a la main des ingr\u00e9dients avec le script suivant: INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Oeuf\" ); INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Farine\" ); INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Beurre\" ); Puis c'est le tour d'une recette: INSERT OR IGNORE INTO Recette ( Nom_Recette ) VALUES ( \"P\u00e2te a cr\u00eapes\" ); A cette \u00e9tape nous avons plusieurs ingr\u00e9dients a notre disposition et une recette mais il n'y a aucun lien entre eux. En effet le lien se fera via la table Constitue . Cette table permet de stocker le lien entre un recette et des ingr\u00e9dients. Pour cr\u00e9er ces liens entre recette et ingr\u00e9dients nous avons donc besoin du script suivant: INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( 1 , 1 ); INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( 1 , 2 ); INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( 1 , 3 ); Via ce script on viens de faire le lien entre la recette portant l'id 1 et les ingr\u00e9dients portant les ids 1 , 2 et 3 . On rappelle que les ids sont cr\u00e9\u00e9s automatiquement et ne peuvent pas \u00eatre modifi\u00e9, ce qui renforce la s\u00e9curit\u00e9 de notre base de donn\u00e9e tout en \u00e9vitant encore les doublons. Je conc\u00e8de que pour l'instant on ne voit pas bien le lien qu'on a cr\u00e9er. Pour le visualiser plus simplement on peut ex\u00e9cuter le script suivant: SELECT Nom_Recette , Nom_Incr\u00e9dient FROM Constitue JOIN Recette ON Constitue . Recette_id = Recette . id JOIN Ingredient ON Constitue . Ingredient_id = Ingredient . id ; Si on le d\u00e9crypte on trouve: On affiche les colonnes Nom_Recette et Nom_Ingredient Venant de la table Constitue On accole la table Recette O\u00f9 la colonne Constitue.Recette_id est \u00e9gale \u00e0 la colonne Recette.id On accole la table Ingredient O\u00f9 la colonne Constitue.Ingredient_id est \u00e9gale \u00e0 la colonne Ingredient.id Via les JOIN on fait donc les liens entre des tables. Pour notre sujet il nous faudra donc litt\u00e9ralement moult JOIN . On remarque aussi qu'il faudrait rajouter un argument pour les Exercices dans un Entrainement. En effet de la mani\u00e8re dont la base a \u00e9t\u00e9 faite il n'est pas possible de trier les exercices d'un entra\u00eenement. On en d\u00e9duit des scripts pr\u00e9c\u00e9dents que pour l'ajout d'une nouvelle recette nous pourrons encha\u00eener des INSERT si la VALUES n'existe pas encore dans la table. Tentons d'\u00e9crire un seul script qui puisse nous permettre : D'ajouter une recette du nom de \"G\u00e2teau a la vanille\" Cr\u00e9er les VALUES n\u00e9cessaires SI ELLE N'EXISTENT PAS Cr\u00e9er les liens entre la recette et les ingr\u00e9dients dans la Table constitue On prendra en recette de ce g\u00e2teau uniquement de l\u2019\u0153uf et de la vanille. INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Oeuf\" ); INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Vanille\" ); INSERT OR IGNORE INTO Recette ( Nom_Recette ) VALUES ( \"G\u00e2teau \u00e0 la Vanille\" ); INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( ( SELECT Recette . id FROM Recette WHERE Recette . Nom_Recette LIKE \"G\u00e2teau \u00e0 la Vanille\" ), ( SELECT id FROM Ingredient WHERE Ingredient . Nom_Ingredient LIKE \"Oeuf\" ) ); INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( ( SELECT Recette . id FROM Recette WHERE Recette . Nom_Recette LIKE \"G\u00e2teau \u00e0 la Vanille\" ), ( SELECT id FROM Ingredient WHERE Ingredient . Nom_Ingredient LIKE \"Vanille\" ) ); Or on remarque bien qu'il est possible d\u2019ex\u00e9cuter plusieurs fois ce script et on obtient une multitude d'enregistrement identique. Il faudra donc cr\u00e9er un index qui permettra d'ignorer l'ajout si la ligne existe d\u00e9j\u00e0: CREATE UNIQUE \"DoubleConstitue\" ON \"Constitue\" ( \"Recette_id\" \"Ingredient_id\" );","title":"Base de donn\u00e9es"},{"location":"exp-bdd/#experimentations-en-base-de-donnees","text":"En utilisant une base de donn\u00e9es bien plus simple (figure Y.1.5) pour faire des tests j'ai pu me rendre compte de certain probl\u00e8mes dans notre base (qui seront r\u00e9gl\u00e9s plus tard). \u00c7a m'a aussi permis de comprendre plusieurs choses expliqu\u00e9es dans la suite. Figure Y.1.5: Base de donn\u00e9es de cuisine Pour cr\u00e9er cette base de donn\u00e9es il faut le script suivant: DROP TABLE IF EXISTS \"Ingredient\" ; CREATE TABLE IF NOT EXISTS \"Ingredient\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"Nom_Ingredient\" TEXT UNIQUE ); DROP TABLE IF EXISTS \"Recette\" ; CREATE TABLE IF NOT EXISTS \"Recette\" ( \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT , \"Nom_Recette\" TEXT UNIQUE ); DROP TABLE IF EXISTS \"Constitue\" ; CREATE TABLE IF NOT EXISTS \"Constitue\" ( \"Recette_id\" INTEGER NOT NULL , \"Ingredient_id\" INTEGER NOT NULL , FOREIGN KEY ( Recette_id ) REFERENCES Recette ( id ) ON DELETE CASCADE ON UPDATE NO ACTION , FOREIGN KEY ( Ingredient_id ) REFERENCES Ingredient ( id ) ON DELETE CASCADE ON UPDATE NO ACTION ); On remarque d\u00e9j\u00e0 que nous avons omis la contrainte UNIQUE pour certain attributs qui permettent d'\u00e9viter les doublons. Ensuite nous avons simplement ajouter a la main des ingr\u00e9dients avec le script suivant: INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Oeuf\" ); INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Farine\" ); INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Beurre\" ); Puis c'est le tour d'une recette: INSERT OR IGNORE INTO Recette ( Nom_Recette ) VALUES ( \"P\u00e2te a cr\u00eapes\" ); A cette \u00e9tape nous avons plusieurs ingr\u00e9dients a notre disposition et une recette mais il n'y a aucun lien entre eux. En effet le lien se fera via la table Constitue . Cette table permet de stocker le lien entre un recette et des ingr\u00e9dients. Pour cr\u00e9er ces liens entre recette et ingr\u00e9dients nous avons donc besoin du script suivant: INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( 1 , 1 ); INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( 1 , 2 ); INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( 1 , 3 ); Via ce script on viens de faire le lien entre la recette portant l'id 1 et les ingr\u00e9dients portant les ids 1 , 2 et 3 . On rappelle que les ids sont cr\u00e9\u00e9s automatiquement et ne peuvent pas \u00eatre modifi\u00e9, ce qui renforce la s\u00e9curit\u00e9 de notre base de donn\u00e9e tout en \u00e9vitant encore les doublons. Je conc\u00e8de que pour l'instant on ne voit pas bien le lien qu'on a cr\u00e9er. Pour le visualiser plus simplement on peut ex\u00e9cuter le script suivant: SELECT Nom_Recette , Nom_Incr\u00e9dient FROM Constitue JOIN Recette ON Constitue . Recette_id = Recette . id JOIN Ingredient ON Constitue . Ingredient_id = Ingredient . id ; Si on le d\u00e9crypte on trouve: On affiche les colonnes Nom_Recette et Nom_Ingredient Venant de la table Constitue On accole la table Recette O\u00f9 la colonne Constitue.Recette_id est \u00e9gale \u00e0 la colonne Recette.id On accole la table Ingredient O\u00f9 la colonne Constitue.Ingredient_id est \u00e9gale \u00e0 la colonne Ingredient.id Via les JOIN on fait donc les liens entre des tables. Pour notre sujet il nous faudra donc litt\u00e9ralement moult JOIN . On remarque aussi qu'il faudrait rajouter un argument pour les Exercices dans un Entrainement. En effet de la mani\u00e8re dont la base a \u00e9t\u00e9 faite il n'est pas possible de trier les exercices d'un entra\u00eenement. On en d\u00e9duit des scripts pr\u00e9c\u00e9dents que pour l'ajout d'une nouvelle recette nous pourrons encha\u00eener des INSERT si la VALUES n'existe pas encore dans la table. Tentons d'\u00e9crire un seul script qui puisse nous permettre : D'ajouter une recette du nom de \"G\u00e2teau a la vanille\" Cr\u00e9er les VALUES n\u00e9cessaires SI ELLE N'EXISTENT PAS Cr\u00e9er les liens entre la recette et les ingr\u00e9dients dans la Table constitue On prendra en recette de ce g\u00e2teau uniquement de l\u2019\u0153uf et de la vanille. INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Oeuf\" ); INSERT OR IGNORE INTO Ingredient ( Nom_Ingredient ) VALUES ( \"Vanille\" ); INSERT OR IGNORE INTO Recette ( Nom_Recette ) VALUES ( \"G\u00e2teau \u00e0 la Vanille\" ); INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( ( SELECT Recette . id FROM Recette WHERE Recette . Nom_Recette LIKE \"G\u00e2teau \u00e0 la Vanille\" ), ( SELECT id FROM Ingredient WHERE Ingredient . Nom_Ingredient LIKE \"Oeuf\" ) ); INSERT OR IGNORE INTO Constitue ( Recette_id , Ingredient_id ) VALUES ( ( SELECT Recette . id FROM Recette WHERE Recette . Nom_Recette LIKE \"G\u00e2teau \u00e0 la Vanille\" ), ( SELECT id FROM Ingredient WHERE Ingredient . Nom_Ingredient LIKE \"Vanille\" ) ); Or on remarque bien qu'il est possible d\u2019ex\u00e9cuter plusieurs fois ce script et on obtient une multitude d'enregistrement identique. Il faudra donc cr\u00e9er un index qui permettra d'ignorer l'ajout si la ligne existe d\u00e9j\u00e0: CREATE UNIQUE \"DoubleConstitue\" ON \"Constitue\" ( \"Recette_id\" \"Ingredient_id\" );","title":"Exp\u00e9rimentations en base de donn\u00e9es"},{"location":"glossaire/","text":"Glossaire API : Une Interface de Programmation d\u2019Application est un ensemble normalis\u00e9 de classes, de m\u00e9thodes, de fonctions et de constantes qui sert de fa\u00e7ade par laquelle un logiciel offre des services \u00e0 d'autres logiciels Benchmark : ou Girls , WODS de r\u00e9f\u00e9rence pour \u00e9valuer les progr\u00e8s. Index : Un index est un outil de performance et un raccourci qui permet d\u2019acc\u00e9der plus rapidement aux donn\u00e9es. MCD : Le Mod\u00e8le Conceptuel de Donn\u00e9e est une repr\u00e9sentation graphique de haut niveau qui permet facilement et simplement de comprendre comment les diff\u00e9rents \u00e9l\u00e9ments sont li\u00e9s entre eux \u00e0 l\u2019aide de diagrammes codifi\u00e9s. MLD : Le Mod\u00e8le Logique des Donn\u00e9es est simplement la repr\u00e9sentation textuelle du MPD. Il s\u2019agit juste de la repr\u00e9sentation en ligne du sch\u00e9ma repr\u00e9sentant la structure de la base de donn\u00e9es. Il n\u2019y a pas de travail pouss\u00e9 \u00e0 r\u00e9aliser \u00e0 cette \u00e9tape, il s\u2019agit juste d\u2019appliquer quelques r\u00e8gles toutes simples. Cette \u00e9tape est parfois omise. MPD : Le Mod\u00e8le Physique de Donn\u00e9e permet de faire \u00e9voluer sa mod\u00e9lisation de haut niveau pour la transformer en un sch\u00e9ma plus proche des contraintes des logiciels de bases de donn\u00e9es. SQL : Structured Query Language est un langage informatique normalis\u00e9 servant \u00e0 exploiter des bases de donn\u00e9es relationnelles. WOD : Workout Of the Day.","title":"Glossaire"},{"location":"glossaire/#glossaire","text":"API : Une Interface de Programmation d\u2019Application est un ensemble normalis\u00e9 de classes, de m\u00e9thodes, de fonctions et de constantes qui sert de fa\u00e7ade par laquelle un logiciel offre des services \u00e0 d'autres logiciels Benchmark : ou Girls , WODS de r\u00e9f\u00e9rence pour \u00e9valuer les progr\u00e8s. Index : Un index est un outil de performance et un raccourci qui permet d\u2019acc\u00e9der plus rapidement aux donn\u00e9es. MCD : Le Mod\u00e8le Conceptuel de Donn\u00e9e est une repr\u00e9sentation graphique de haut niveau qui permet facilement et simplement de comprendre comment les diff\u00e9rents \u00e9l\u00e9ments sont li\u00e9s entre eux \u00e0 l\u2019aide de diagrammes codifi\u00e9s. MLD : Le Mod\u00e8le Logique des Donn\u00e9es est simplement la repr\u00e9sentation textuelle du MPD. Il s\u2019agit juste de la repr\u00e9sentation en ligne du sch\u00e9ma repr\u00e9sentant la structure de la base de donn\u00e9es. Il n\u2019y a pas de travail pouss\u00e9 \u00e0 r\u00e9aliser \u00e0 cette \u00e9tape, il s\u2019agit juste d\u2019appliquer quelques r\u00e8gles toutes simples. Cette \u00e9tape est parfois omise. MPD : Le Mod\u00e8le Physique de Donn\u00e9e permet de faire \u00e9voluer sa mod\u00e9lisation de haut niveau pour la transformer en un sch\u00e9ma plus proche des contraintes des logiciels de bases de donn\u00e9es. SQL : Structured Query Language est un langage informatique normalis\u00e9 servant \u00e0 exploiter des bases de donn\u00e9es relationnelles. WOD : Workout Of the Day.","title":"Glossaire"},{"location":"help/","text":"TESTS : Outil de requ\u00eate en ligne: sqliteonline.com Outil de requ\u00eate en ligne: dbdiagram.io BDD : Vocabulaire et m\u00e9thodologie : base-de-donnees.com Vocabulaire et technologies : wikipedia.org Sqlite : sqlite.org Cours, Technologie, Tutoriels : sqlitetutorial.net Outils et Logiciels : Diagrammes et dessins draw.io Mod\u00e9lisation de la BDD AnalyseSI Coloration syntaxique : tohtml.com Visualisation et gestion de BDD : DB Browser Editeur/Visualiseur JSON: JSONedit","title":"Liens et outils"}]}